{"posts":[{"title":"爬取微博搜索图片","content":" import requests import re import os import time #cookie = '自己写奥' header = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4144.2 Safari/537.36', 'cookie': '自己写奥' } get_order = input('是否启动程序? yes or no: ') or 'yes' number = 1 content = 'ghs' #搜索内容如有特殊字符，需转换 while True: if get_order != 'no': print('抓取中......') # 下面的链接填写微博搜索的链接 url = f'https://s.weibo.com/weibo?q={content}&amp;wvr=6&amp;b=1&amp;Refer=SWeibo_box&amp;page={number}' response = requests.get(url, headers=header) result = response.text print(result) detail = re.findall('data=&quot;uid=(.*?)&amp;mid=(.*?)&amp;pic_ids=(.*?)&quot;&gt;', result) for part in detail: head = part[0] feet = part[2] feet = feet.split(',') for foot in feet: url_x = f'https://wx1.sinaimg.cn/large/{foot}.jpg' # 这里就是大图链接了 response_photo = requests.get(url_x, headers=header) file_name = url_x[-10:] #先创建portrait文件夹 if not os.path.exists('f:/20200628/portrait/'+head): os.mkdir('f:/20200628/portrait/'+head) # 保存文件 with open('f:/20200628/portrait/'+head + '/' + file_name, 'ab') as f: f.write(response_photo.content) time.sleep(0.5) print('获取完毕') get_order = input('是否继续获取下一页? Y:yes N:no: ') if get_order != 'no': number += 1 else: print('程序结束') break else: print('程序结束') break ","link":"https://hakunassan.github.io/post/pa-qu-wei-bo-sou-suo-tu-pian/"},{"title":"基于tkinter的项目管理","content":"王多鱼都要投这项目！ 代码 import tkinter as tk from tkinter import messagebox import sqlite3 import os # 初始化创建数据库 if os.path.isfile('project.db'): pass else: open('project.db', 'w') conn = sqlite3.connect('project.db') cursor = conn.cursor() sql_create = ''' CREATE TABLE `project`( `project_date` CHAR(50), `project_name` CHAR(50), `project_illustration` CHAR(500) ) ''' cursor.execute(sql_create) conn.commit() conn.close() class App: def __init__(self, root): root.title(&quot;项目记录&quot;) root.geometry('800x600') # 设置窗体的大小 self.frame1 = tk.Frame(root, bg='red', width=800, height=50) # pack()自动调节组件自身尺寸 self.frame1.pack() # 创建一个框架 # 框架的作用一般是在复杂的布局中起到将组件分组的作用 self.frame2 = tk.Frame(root, bg='green', width=800, height=500) # pack()自动调节组件自身尺寸 self.frame2.pack_forget() # 创建一个框架 # 框架的作用一般是在复杂的布局中起到将组件分组的作用 self.frame3 = tk.Frame(root, bg='blue', width=800, height=500) # pack()自动调节组件自身尺寸 self.frame3.pack() # 创建一个框架 # 框架的作用一般是在复杂的布局中起到将组件分组的作用 self.frame4 = tk.Frame(root, bg='yellow', width=800, height=500) # pack()自动调节组件自身尺寸 self.frame4.pack_forget() # 创建一个捐助按钮 self.Button_donate = tk.Button(self.frame1, text=&quot;捐助&quot;, fg=&quot;blue&quot;, command=self.Button_donate) self.Button_donate.pack(side=tk.RIGHT) # 创建一个新增按钮，fg是foreground（前景色） self.Button_new = tk.Button(self.frame1, text=&quot;新增&quot;, fg=&quot;blue&quot;, command=self.Button_new) self.Button_new.pack(side=tk.LEFT) # 创建一个查询按钮 self.Button_search = tk.Button(self.frame1, text=&quot;查询&quot;, fg=&quot;red&quot;, command=self.Button_search) self.Button_search.pack(side=tk.RIGHT) # 创建一个项目日期输入框 self.Project_date_info = tk.Label(self.frame2, text='项目日期', font=('Arial', 12)) self.Project_date_info.place(x=0, y=10, anchor='nw') self.Project_date = tk.Entry(self.frame2, bd=2, width=10) self.Project_date.place(x=0, y=50, anchor='nw') # 创建一个项目名称输入框 self.Project_name_info = tk.Label(self.frame2, text='项目名称', font=('Arial', 12)) self.Project_name_info.place(x=100, y=10, anchor='nw') self.Project_name = tk.Entry(self.frame2, bd=2, width=20) self.Project_name.place(x=100, y=50, anchor='nw') # 创建一个项目说明输入框 self.Project_illustration_info = tk.Label(self.frame2, text='项目说明', font=('Arial', 12)) self.Project_illustration_info.place(x=300, y=10, anchor='nw') self.Project_illustration = tk.Entry(self.frame2, bd=2, width=50) self.Project_illustration.place(x=300, y=50, anchor='nw') # 创建一个保存按钮 self.Button_save = tk.Button(self.frame2, text=&quot;保存&quot;, fg=&quot;black&quot;, command=self.Project_save) self.Button_save.place(x=750, y=45, anchor='nw') # 创建一个项目名称输入框 self.Project_name_info = tk.Label(self.frame3, text='项目名称', font=('Arial', 12)) self.Project_name_info.place(x=50, y=10, anchor='nw') self.Project_sname = tk.Entry(self.frame3, bd=2, width=20) self.Project_sname.place(x=50, y=50, anchor='nw') # 创建一个查询按钮 self.Button_search = tk.Button(self.frame3, text=&quot;项目查询&quot;, fg=&quot;black&quot;, command=self.Project_search) self.Button_search.place(x=690, y=45, anchor='nw') # 创建一个展示数据区域 self.Project_show = tk.Text(self.frame3, width=100, height=30) self.Project_show.place(x=50, y=80, anchor='nw') #创建捐助图片 self.photo = tk.PhotoImage(file='F:\\\\python-pro\\\\20200309\\\\donate2.gif') self.donate_photo = tk.Label(self.frame4, image=self.photo).pack() def Button_new(self): self.frame2.pack() self.frame3.pack_forget() self.frame4.pack_forget() def Button_search(self): self.frame2.pack_forget() self.frame3.pack() self.frame4.pack_forget() def Button_donate(self): self.frame4.pack() self.frame2.pack_forget() self.frame3.pack_forget() def Project_save(self): date = self.Project_date.get() name = self.Project_name.get() illustration = self.Project_illustration.get() con = sqlite3.connect('project.db') cur = con.cursor() try: sql = &quot;insert into project (project_date,project_name,project_illustration) values ('%s','%s','%s')&quot; sql1 = sql % (date, name, illustration) cur.execute(sql1) except Exception as e: con.rollback() tk.messagebox.showinfo('警告', '保存失败！') finally: con.commit() cur.close() con.close() tk.messagebox.showinfo('提示', '保存成功！') def Project_search(self): self.Project_show.delete('1.0', 'end') sname = self.Project_sname.get() con = sqlite3.connect('project.db') cur = con.cursor() sql = &quot;select * from project where project_name like '%%{}%%'&quot;.format(sname) cur.execute(sql) con.commit() data = cur.fetchall() for result in data: self.Project_show.insert(&quot;insert&quot;, result) self.Project_show.insert(&quot;insert&quot;, '\\n') cur.close() con.close() root = tk.Tk() app = App(root) # 开始主事件循环 root.mainloop() ","link":"https://hakunassan.github.io/post/ji-yu-tkinter-de-xiang-mu-guan-li/"},{"title":"调用百度翻译生成语音","content":"秀到我了 代码说明 导入requests、playsound模块 通过url和cookie调用百度翻译网页生成语音 保存语音文件至程序目录的test.mp3中 使用playsound方法播放语音 from requests import get from playsound import playsound trans_url = 'https://fanyi.baidu.com/gettts?' content = input(&quot;输入一句话：&quot;) # content = &quot;&quot;&quot; # 挫折和离别不过是生命中的点缀 # &quot;&quot;&quot; headers = { 'Cookie': 'BAIDUID=1FD619A8398DD698091712D9EE68788E:FG=1', &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&quot; } params = { 'lan': 'zh', 'text': '{}'.format(content), 'spd': '5', 'source': 'web' } response = get(url=trans_url, params=params, headers=headers).content with open('test.mp3', 'wb') as f: f.write(response) f.flush() playsound('test.mp3') ","link":"https://hakunassan.github.io/post/diao-yong-bai-du-fan-yi-sheng-cheng-yu-yin/"},{"title":"Centos7.6安装Redis5.0.5","content":"按教程操作记录 # 在centOS下安装redis5.0.5 cd /usr/local # 进入所要安装的目录 wget http://download.redis.io/releases/redis-5.0.5.tar.gz # 下载redis5.0.5 tar -xzf redis-5.0.5.tar.gz # 解压 cd /usr/local/redis-5.0.5 # 进入解压目录 yum install gcc gcc-c++ -y make # 编译 # 配置redis # 若部署在远程服务器，例如阿里云，需要在安全策略组中加入6379端口的访问权限，否则防火墙会阻止访问6379端口，导致无法正常连接redis #开放6379端口 firewall-cmd --zone=public --add-port=6379/tcp --permanent #重新载入，使其生效 firewall-cmd --reload cd /usr/local/redis-5.0.5 # 进入安装目录 cp redis.conf redis.conf.bak # 备份redis配置文件 vim redis.conf # 编辑配置文件 requirepass xxxxxxxxxx # 设置访问密码（可以不设置） 注释掉 bind 127.0.0.1 # 设置redis为任何ip都可访问，如需设置指定ip，则添加bind protected-mode no # 设置为no，否则不能保证全网段进行访问 daemonize yes # 设置为yes，保证以守护进程的方式运行redis 修改完成后保存退出 # 建立redis-server、redis-cli软连接 ln -s /usr/local/redis-5.0.5/src/redis-server /usr/bin/redis-server ln -s /usr/local/redis-5.0.5/src/redis-cli /usr/bin/redis-cli # 直接运行redis-server将以前端形式启动redis #redis-cli测试 redis-cli redis&gt;set foo bar OK redis&gt;get foo &quot;bar&quot; #即成功！ ","link":"https://hakunassan.github.io/post/centos76-an-zhuang-redis505/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://hakunassan.github.io/post/hello-gridea/"}]}